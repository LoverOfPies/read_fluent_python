# Конспект по книге Рамальо Лучано - Python. К вершинам мастерства - 2016 

## Часть 1. Пролог

### Глава 1. Модель данных в языке Python

#### Были рассмотрены:

#### 1) Колода карт на Python
* Пример в модуле **part1/chapter1/french_deck.py**

#### 2) Как используются специальные методы.
* Специальные методы предназначены для вызова интерпретатором.
* Как правило, специальный метод вызывается неявно.
* Если необходимо обратиться к специальному методу, то обычно лучше вызвать 
соответствующую встроенную функцию.

#### 3) Эмуляция числовых типов
* Пример в модуле **part1/chapter1/vector.py**

#### 4) Строковое представление
* Специальный метод \_\_repr__ вызывается встроенной функцией repr для получения строкового представления объекта.
* Интерактивная оболочка и отладчик вызывают функцию repr, передавая ей результат вычисления выражения.
* Строка, возвращаемая методом \_\_repr__, должна быть однозначно определена и по возможности соответствовать коду, необходимому для восстановления 
объекта.
* В отличие от \_\_repr__, метод \_\_str__ вызывается конструктором str() и неявно используется в функции print.
* Если вы реализуете только один из этих двух методов, то пусть это будет 
\_\_repr__, потому что в отсутствие пользовательского метода \_\_str__ интерпретатор Python вызывает \_\_repr__.

#### 5) Булево значение пользовательского типа
* Хотя в Python есть тип bool, интерпретатор принимает любой объект в булевом 
контексте, например в условии if, в управляющем выражении цикла while или в 
качестве операнда операторов and, or и not. Чтобы определить, является ли выражение истинным или ложным, применяется функция bool(x), которая возвращает 
True или False.
* По умолчанию любой объект пользовательского класса считается истинным, 
но положение меняется, если реализован хотя бы один из методов \_\_bool__ или \_\_len__.
* Функция bool(x), по существу, вызывает x.\_\_bool__() и использует полученный результат. Если метод \_\_bool__ не реализован, то Python пытается вызвать 
x.\_\_len__() и при получении нуля функция bool возвращает False. В противном случае bool возвращает True.

#### 6) Сводка специальных методов
| Категория                           | Имена методов                                                           |
|-------------------------------------|-------------------------------------------------------------------------|
| Представление в виде строк и байтов | __repr__, __str__, __format__, __bytes__                                |
| Преобразование в число              | __abs__, __bool__, __complex__, __int__, __float__, __hash__, __index__ |

TODO: Разобраться с таблицами, как проще оформить

#### 7) Почему len – не метод
* Функция len(x) работает очень быстро, если x – объект встроенного типа. Для 
встроенных объектов интерпретатор CPython вообще не вызывает методы, а просто читает значение, 
хранящееся в поле C-структуры.
* Иначе говоря, len не вызывается как метод, потому что играет особую роль 
в модели данных Python, равно как и abs. Но благодаря специальному методу 
\_\_len__ можно вызывать функцию len и для пользовательских объектов.

#### 8) Резюме
* Благодаря реализации специальных методов пользовательские объекты могут 
вести себя, как встроенные типы. Это позволяет добиться выразительного стиля 
кодирования, который сообщество считает «питоническим».
* Важное требование к объекту Python – обеспечить полезные строковые 
представления себя: одно – для отладки и протоколирования, другое – для показа пользователям. 
Именно для этой цели предназначены специальные методы **\_\_repr__** и \_\_str__.


## Часть 2. Структуры данных

### Глава 2. Массив последовательностей

#### Были рассмотрены:

#### 1) Общие сведения о встроенных последовательностях
Стандартная библиотека предлагает богатый выбор типов последовательностей, 
реализованных на C:
* **Контейнерные последовательности.** 
В последовательностях list, tuple и collections.deque можно хранить элементы разных типов.
* **Плоские последовательности.**
В последовательностях str, bytes, bytearray, memoryview и array.array можно хранить элементы только одного типа.

В контейнерных последовательностях хранятся ссылки на объекты любого 
типа, тогда как в плоских последовательностях – сами значения. Поэтому плоские 
последовательности компактнее, но могут содержать только значения примитивных типов: символы, байты и числа.

Последовательности можно также классифицировать по признаку изменяемости:
* **Изменяемые последовательности.**
list, bytearray, array.array, collections.deque и memoryview.
* **Неизменяемые последовательности.**
tuple, str и bytes

Самый фундаментальный тип последовательности – список list, изменяемый 
и допускающий хранение объектов разных типов.

#### 2) Списковое включение и генераторные выражения
Чтобы быстро построить последовательность, можно воспользоваться списковым 
включением (если конечная последовательность – список) 
или генераторным выражением (для всех прочих типов последовательностей).

Многие программисты для краткости называют списковое включение listcomp, а генераторное выражение – genexp.

**Списковое включение и удобочитаемость**

У спискового включения только одна задача – построить новый список, ничего другого оно не умеет

В программе на Python переход на другую строку внутри пар 
скобок [], {} и () игнорируется. Поэтому при построении многострочных списков, списковых включений, генераторных выражений, словарей и прочего можно обходиться без уродливой косой 
черты \ для экранирования символа новой строки.

Пример в модуле **part2/chapter2/listcomp.py**

**Сравнение спискового включения с map и filter**

Списковое включение может делать все, что умеют функции map и filter

Пример в модуле **part2/chapter2/diff_listcomp_filter_map.py**

**Декартовы произведения**

С помощью спискового включения можно сгенерировать список элементов 
декартова произведения двух и более итерируемых объектов. Декартово произведение – это множество кортежей, включающих по одному элементу из каждого 
объекта-сомножителя. Длина результирующего списка равна произведению длин 
входных объектов.

Пример в модуле **part2/chapter2/decart_mul.py**

**Генераторные выражения**

Инициализацию кортежей, массивов и других последовательностей тоже можно начать с использования спискового включения, но genexp экономит память, 
т. к. отдает элементы по одному, применяя протокол итератора, вместо того чтобы 
сразу строить целиком список для передачи другому конструктору.

Синтаксически генераторное выражение выглядит так же, как списковое включение, только заключается не в квадратные скобки, а в круглые

#### 3) Кортеж – не просто неизменяемый список
У кортежей две функции: 
* использование в качестве неизменяемых списков 
* использование в качестве записей с неименованными полями

**Кортежи как записи**

В кортеже хранится запись: каждый элемент кортежа содержит данные одного 
поля, а его позиция определяет семантику поля.

Если рассматривать кортеж только как неизменяемый список, то количество и 
порядок элементов могут быть важны или не важны в зависимости от контекста. 
Но если считать кортеж набором полей, то количество элементов часто фиксировано, 
а порядок имеет первостепенное значение.

Пример в модуле **part2/chapter2/tuple_record.py**

**Распаковка кортежа**

Распаковка кортежа работает для любого итерируемого объекта. 
Единственное требование заключается в том, чтобы итерируемый 
объект отдавал ровно один элемент для каждой переменной в принимающем кортеже, если только не указана звездочка (*), 
которая забирает все оставшиеся элементы.

Самая очевидная форма распаковки кортежа – параллельное присваивание, т. е. 
присваивание элементов итерируемого объекта кортежу переменных.

Элегантное применение распаковки кортежа – обмен значений двух переменных без создания временной переменной.

Иногда нас интересуют не все элементы кортежа, тогда остальные можно распаковывать в фиктивную переменную, например с именем `_`.

При создании интернационализированных программ лучше не употреблять `_` в качестве имени фиктивной переменной, 
потому что в соответствии с рекомендациями в документации по модулю gettext так принято обозначать псевдоним функции 
**gettext.gettext**

#### 4) Использование * для выборки лишних элементов

