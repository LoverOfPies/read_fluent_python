# Конспект по книге Рамальо Лучано - Python. К вершинам мастерства - 2016 

## Часть 1. Пролог

### Глава 1. Модель данных в языке Python

#### Были рассмотрены:

#### 1) Колода карт на Python
* Пример в модуле `part1/chapter1/french_deck.py`

#### 2) Как используются специальные методы.
* Специальные методы предназначены для вызова интерпретатором.
* Как правило, специальный метод вызывается неявно.
* Если необходимо обратиться к специальному методу, то обычно лучше вызвать 
соответствующую встроенную функцию.

#### 3) Эмуляция числовых типов
* Пример в модуле `part1/chapter1/vector.py`

#### 4) Строковое представление
* Специальный метод `__repr__` вызывается встроенной функцией repr для получения строкового представления объекта.
* Интерактивная оболочка и отладчик вызывают функцию `repr`, передавая ей результат вычисления выражения.
* Строка, возвращаемая методом `__repr__`, должна быть однозначно определена и по возможности соответствовать коду, необходимому для восстановления 
объекта.
* В отличие от `__repr__`, метод `__str__` вызывается конструктором `str()` и неявно используется в функции `print`.
* Если вы реализуете только один из этих двух методов, то пусть это будет 
`__repr__`, потому что в отсутствие пользовательского метода `__str__` интерпретатор Python вызывает `__repr__`.

#### 5) Булево значение пользовательского типа
* Хотя в Python есть тип `bool`, интерпретатор принимает любой объект в булевом 
контексте, например в условии `if`, в управляющем выражении цикла `while` или в 
качестве операнда операторов `and, or и not`. Чтобы определить, является ли выражение истинным или ложным, применяется функция `bool(x)`, которая возвращает 
`True` или `False`.
* По умолчанию любой объект пользовательского класса считается истинным, 
но положение меняется, если реализован хотя бы один из методов `__bool__` или `__len__`.
* Функция `bool(x)`, по существу, вызывает `x.__bool__()` и использует полученный результат. Если метод `__bool__` не реализован, то Python пытается вызвать 
`x.__len__()` и при получении нуля функция `bool` возвращает `False`. В противном случае `bool` возвращает `True`.

#### 6) Сводка специальных методов
| Категория                           | Имена методов                                                             |
|-------------------------------------|---------------------------------------------------------------------------|
| Представление в виде строк и байтов | `__repr__, __str__, __format__, __bytes__`                                |
| Преобразование в число              | `__abs__, __bool__, __complex__, __int__, __float__, __hash__, __index__` |

TODO: Разобраться с таблицами, как проще оформить

#### 7) Почему len – не метод
* Функция `len(x)` работает очень быстро, если `x` – объект встроенного типа. Для 
встроенных объектов интерпретатор CPython вообще не вызывает методы, а просто читает значение, 
хранящееся в поле C-структуры.
* Иначе говоря, `len` не вызывается как метод, потому что играет особую роль 
в модели данных Python, равно как и `abs`. Но благодаря специальному методу 
`__len__` можно вызывать функцию len и для пользовательских объектов.

#### 8) Резюме
* Благодаря реализации специальных методов пользовательские объекты могут 
вести себя, как встроенные типы. Это позволяет добиться выразительного стиля 
кодирования, который сообщество считает «питоническим».
* Важное требование к объекту Python – обеспечить полезные строковые 
представления себя: одно – для отладки и протоколирования, другое – для показа пользователям. 
Именно для этой цели предназначены специальные методы `__repr__` и `__str__`.


## Часть 2. Структуры данных

### Глава 2. Массив последовательностей

#### Были рассмотрены:

#### 1) Общие сведения о встроенных последовательностях
Стандартная библиотека предлагает богатый выбор типов последовательностей, 
реализованных на C:
* **Контейнерные последовательности.** 
В последовательностях `list, tuple и collections.deque` можно хранить элементы разных типов.
* **Плоские последовательности.**
В последовательностях `str, bytes, bytearray, memoryview и array.array` можно хранить элементы только одного типа.

В контейнерных последовательностях хранятся ссылки на объекты любого 
типа, тогда как в плоских последовательностях – сами значения. Поэтому плоские 
последовательности компактнее, но могут содержать только значения примитивных типов: символы, байты и числа.

Последовательности можно также классифицировать по признаку изменяемости:
* **Изменяемые последовательности.**
`list, bytearray, array.array, collections.deque и memoryview.`
* **Неизменяемые последовательности.**
`tuple, str и bytes`

Самый фундаментальный тип последовательности – список list, изменяемый 
и допускающий хранение объектов разных типов.

#### 2) Списковое включение и генераторные выражения
Чтобы быстро построить последовательность, можно воспользоваться списковым 
включением (если конечная последовательность – список) 
или генераторным выражением (для всех прочих типов последовательностей).

Многие программисты для краткости называют списковое включение `listcomp`, а генераторное выражение – `genexp`.

**Списковое включение и удобочитаемость**

У спискового включения только одна задача – построить новый список, ничего другого оно не умеет

В программе на Python переход на другую строку внутри пар 
скобок [], {} и () игнорируется. Поэтому при построении многострочных списков, списковых включений, 
генераторных выражений, словарей и прочего можно обходиться без уродливой косой 
черты \ для экранирования символа новой строки.

Пример в модуле `part2/chapter2/listcomp.py`

**Сравнение спискового включения с map и filter**

Списковое включение может делать все, что умеют функции `map` и `filter`

Пример в модуле `part2/chapter2/diff_listcomp_filter_map.py`

**Декартовы произведения**

С помощью спискового включения можно сгенерировать список элементов 
декартова произведения двух и более итерируемых объектов. Декартово произведение – это множество кортежей, включающих по одному элементу из каждого 
объекта-сомножителя. Длина результирующего списка равна произведению длин 
входных объектов.

Пример в модуле `part2/chapter2/decart_mul.py`

**Генераторные выражения**

Инициализацию кортежей, массивов и других последовательностей тоже можно начать с использования спискового включения, но `genexp` экономит память, 
т. к. отдает элементы по одному, применяя протокол итератора, вместо того чтобы 
сразу строить целиком список для передачи другому конструктору.

Синтаксически генераторное выражение выглядит так же, как списковое включение, только заключается не в квадратные скобки, а в круглые

#### 3) Кортеж – не просто неизменяемый список
У кортежей две функции: 
* использование в качестве неизменяемых списков 
* использование в качестве записей с неименованными полями

**Кортежи как записи**

В кортеже хранится запись: каждый элемент кортежа содержит данные одного 
поля, а его позиция определяет семантику поля.

Если рассматривать кортеж только как неизменяемый список, то количество и 
порядок элементов могут быть важны или не важны в зависимости от контекста. 
Но если считать кортеж набором полей, то количество элементов часто фиксировано, 
а порядок имеет первостепенное значение.

Пример в модуле `part2/chapter2/tuple_record.py`

**Распаковка кортежа**

Распаковка кортежа работает для любого итерируемого объекта. 
Единственное требование заключается в том, чтобы итерируемый 
объект отдавал ровно один элемент для каждой переменной в принимающем кортеже, если только не указана звездочка (*), 
которая забирает все оставшиеся элементы.

Самая очевидная форма распаковки кортежа – параллельное присваивание, т. е. 
присваивание элементов итерируемого объекта кортежу переменных.

Элегантное применение распаковки кортежа – обмен значений двух переменных без создания временной переменной.

Иногда нас интересуют не все элементы кортежа, тогда остальные можно распаковывать в фиктивную переменную, например с именем `_`.

При создании интернационализированных программ лучше не употреблять `_` в качестве имени фиктивной переменной, 
потому что в соответствии с рекомендациями в документации по модулю gettext так принято обозначать псевдоним функции 
`gettext.gettext`

**Использование * для выборки лишних элементов**

Пример в модуле `part2/chapter2/unpack_args.py`

**Распаковка вложенного кортежа**

Пример в модуле `part2/chapter2/unpack_inner_tuple.py`

**Именованные кортежи**

Экземпляры класса, построенного с помощью namedtuple, потребляют ровно столько памяти, сколько кортежи, потому что 
имена полей хранятся в определении класса. При этом они занимают меньше памяти, чем обычные объекты, 
так как атрибуты не хранятся в атрибуте `__dict__` на уровне экземпляра.

Пример в модуле `part2/chapter2/namedtuple_example.py`

**Кортежи как неизменяемые списки**

`tuple` поддерживает все методы `list`, не связанные с добавлением или удалением элементов, за одним 
исключением – у кортежа нет метода `__reversed__`. Но это просто оптимизация; 
вызов `reversed(my_tuple)` работает и без него.

TODO: тут разместить таблицу сравнения list и tuple

#### 4) Получение среза

Общей особенностью классов list, tuple, str 
и прочих типов последовательностей в Python является поддержка операций среза.

**Почему в срезы и диапазоны не включается последний элемент**

Принятое в Python соглашение не включать последний элемент в срезы и диапазоны соответствует 
индексации с нуля, принятой в Python, C и многих других языках.

* Легко понять, какова длина среза или диапазона, если задана только конечная позиция: 
и `range(3)`, и `my_list[:3]` содержат три элемента.
* Легко вычислить длину среза или диапазона, если заданы начальная и конечная позиция, 
достаточно вычислить их разность `stop - start`.
* Легко разбить последовательность на две непересекающиеся части 
по любому индексу `x`: нужно просто взять `my_list[:x]` и `my_list[x:]`.

**Объекты среза**

**Многомерные срезы и многоточие**

**Присваивание срезу**

#### 5) Использование + и * для последовательностей

**Построение списка списков**

**Составное присваивание последовательностей**

**Головоломка: присваивание A +=**

#### 6) Метод list.sort и встроенная функция sorted



